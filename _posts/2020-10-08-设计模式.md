---
layout:     post
title:   设计模式读书笔记
subtitle:   
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
category: 
tags:
       - Git
---

>stay hungry. stay foolish 

## 创建型

### 1、单例

简介：

只需要**一个实例**，整个系统只需要**一个全局对象**，如各种Manager、Factory，防止别人new出多个对象，单例模式严格来说有8种写法，其中有两种是完美的



应用场景：

* 如某个服务器程序中，将服务器的**配置信息**放到一个文件中，这些配置数据由一个单例对象统一读取，然后服务器进程中的对象再通过这个单例对象获取到配置信息

* 重量级对象，如数据库**连接池**、多线程的**线程池**



为什么用单例：对象在整个系统中只有一份，所有请求都用同一个对象来处理，如**service和Dao**层对象一般都是单例，没有必要每个请求都新建一个对象，这样会**浪费CPU和内存**



为什么使用多例：对象在系统中可以有多个实例，每个请求用一个新的对象来处理，如**action**,这样可以防止并发问题，即一个请求改变了对象的状态，此时对象又处理另一个请求，而之前请求对对象状态的改变导致对象对另一个请求做了错误处理

```java
/**
 * 饿汉式
 * <p>
 * 加载EagerSingleton类时就会生成实例，JVM保证线程安全
 * 简单实用，推荐！
 * 唯一缺点，不管用到与否，类加载时就会创建实例
 */
public class EagerSingleton {
    private static final EagerSingleton eagerSingleton = new EagerSingleton();

    private EagerSingleton() {

    }

    public static EagerSingleton getInstance() {
        return eagerSingleton;
    }
}
```



```java
/**
 * Description:
 * 饿汉式2
 * 把实例化过程放到静态代码块中，本质上和EagerSingleton是一样的
 *
 * @author guchaolong
 * @date 2020/5/24 22:21
 */
public class EagerSingleton02 {
    private static EagerSingleton02 instance;

    static {
        instance = new EagerSingleton02();
    }

    private EagerSingleton02() {

    }

    public static EagerSingleton02 getInstance() {
        return instance;
    }
}
```



```java
/**
 * 懒汉式
 * 第一次调用getInstance()方法时才生成
 */
public class LazySingleton {
    //volatile关键字，可以防止指令重排序
    private volatile static LazySingleton instance = null;

    private LazySingleton() {

    }

    /**
     * 非线程安全
     * @return
     */
    public static LazySingleton getInstance0(){
        if(instance == null){
            instance = new LazySingleton();
        }
        return instance;
    }

    /**
     * 加上synchronized，防止多线程同时首次访问,因为是加在方法上，效率不高
     * @return
     */
    public static synchronized LazySingleton getInstance() {
        if (instance == null) {
            instance = new LazySingleton();
        }
        return instance;
    }

    /**
     * 双重检查 性能较高
     * @return
     */
    public static LazySingleton getInstance2() {
        if (instance == null) {
            synchronized (LazySingleton.class) {
                if (instance == null) {
                    instance = new LazySingleton();
                }
            }
        }
        return instance;
    }

}
```



```java
/**
 * Description:加载外部类时不会加载内部类，这样可以实现懒加载
 *
 * @author guchaolong
 * @date 2020/5/24 22:31
 */
public class LazySingleton02 {

    private LazySingleton02() {

    }

    /**
     * 私有静态内部类
     */
    private static class SingletonHolder {
        private final static LazySingleton02 instance = new LazySingleton02();
    }

    public static LazySingleton02 getInstance() {
        return SingletonHolder.instance;
    }
}
```



```java
/**
 * Description:
 * 不仅可以实现单例，还可以防止反序列化
 * <p>
 * 在effective java（这本书真的很棒）中说道，最佳的单例实现模式就是枚举模式。
 * 利用枚举的特性，让JVM来帮我们保证线程安全和单一实例的问题。除此之外，写法还特别简单
 * <p>
 * 直接通过Singleton.INSTANCE.doSomething()的方式调用即可。方便、简洁又安全
 *
 * @author guchaolong
 * @date 2020/5/24 22:40
 */
public enum SingletonEnum {
    INSTANCE;

    public void doSomething() {
        System.out.println("doSomething");
    }
}
```



### 2、原型

### 对象的创建与使用-工厂的作用

- 一个对象相关的职责

  1. 对象**本身**所具有的职责
  2. **创建**对象的职责
  3. **使用**对象的职责

- Java中创建对象的方式

  1. new直接创建（最简单，但是灵活性较差）
  2. 反射
  3. clone()
  4. 通过工厂类创建对象

  ```java
  
  ```

  在LoginAction类中定义了一个UserDAO类型的对象udao，在LoginAction的构造函数中创建了JDBCUserDAO类型的udao对象，并在execute()方法中调用了udao对象的findUserById()方法，这段代码看上去并没有什么问题。下面我们来分析一下LoginAction和UserDAO之间的关系，LoginAction类负责创建了一个UserDAO子类的对象并使用UserDAO的方法来完成相应的业务处理，也就是说LoginAction即负责udao的创建又负责udao的使用，**创建对象和使用对象的职责耦合在一起**，这样的设计会导致一个很严重的问题：如果在LoginAction中希望能够使用UserDAO的另一个子类如HibernateUserDAO类型的对象，必须修改LoginAction类的源代码，违反了“开闭原则”

  最常用的一种解决方法是将udao对象的创建职责从LoginAction类中移除，在LoginAction类之外创建对象，那么谁来负责创建UserDAO对象呢？答案是：工厂类。通过引入工厂类，客户类（如LoginAction）不涉及对象的创建，对象的创建者也不会涉及对象的使用

  将对象的创建和使用分离还有一个好处：防止用来实例化一个类的数据和代码在多个类中到处都是，可以将有关创建的知识搬移到一个工厂类中，这在Joshua Kerievsky的《重构与模式》一书中有专门的一节来进行介绍。因为有时候我们创建一个对象不只是简单调用其构造函数，还需要设置一些参数，可能还需要配置环境，如果将这些代码散落在每一个创建对象的客户类中，势必会出现代码重复、创建蔓延的问题，而这些客户类其实无须承担对象的创建工作，它们只需使用已创建好的对象就可以了。此时，可以引入工厂类来封装对象的创建逻辑和客户代码的实例化/配置选项

  是否需要为设计中的每一个类都配备一个工厂类？答案是：具体情况具体分析。如果产品类很简单，而且不存在太多变数，其构造过程也很简单，此时无须为其提供工厂类，直接在使用之前实例化即可，例如Java语言中的String类，我们就无须为它专门提供一个StringFactory，这样做反而有点像杀鸡用牛刀，大材小用，而且会导致工厂泛滥，增加系统的复杂度。


### 简单工厂模式

- 简介

  当需要使用一个对象的时候，普通的做法是new，需要其他对象的时候，又要改代码，new其他对象，这样的话破坏了封装性，可以使用一个工厂类，负责该系列对象的创建，使用的时候直接调用工厂类的方法就行，调用方不需要知道创建的细节

- 角色

  - **Factory（工厂角色）：**工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product
  - **Product（抽象产品角色）：**它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象
  - **ConcreteProduct（具体产品角色）：**它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法

- 类图



  ![1590593557215](https://raw.githubusercontent.com/guchaolong/guchaolong.github.io/master/_posts_img/design_pattern/1590593557215.png)

  ```java
  //基类对象，抽象的支付方法
  public abstract class AbstractPay{
      public abstract void pay();
  }
  
  //具体的支付方式
  public class CashPay extends AbstractPay {
      @Override
      public void pay() {
          System.out.println("现金支付");
      }
  }
  
  //具体的支付方式
  public class CreditcardPay extends AbstractPay {
      @Override
      public void pay() {
          System.out.println("信用卡支付");
      }
  }
  
  /**
   *
   * 获得支付方式的工厂类，根据传入的参数获取相应的支付方式
   *
   * 如果新增支付方式，就需要修改这个工厂类（违法开闭原则）
   */
  public class PayMethodFactory {
      public static AbstractPay getPay(String pay){
          //此处可以有前置操作，如权限判断、日志记录等
          if("cash".equals(pay)){
              return new CashPay();
          }else if("creditcard".equals(pay)){
              return new CreditcardPay();
          }
          return null;
      }
  }
  
  /**
   * 获取一个抽象类型的支付方式，传入参数 取得相应的具体支付方式
   */
  public class Client {
      public static void main(String[] args) {
          AbstractPay pay = PayMethodFactory.getPay("cash");
          pay.pay();
      }
  }
  ```



### 3、工厂方法

- 概述

  在简单工厂模式中只提供一个工厂类，该工厂类处于对产品类进行实例化的中心位置，它需要知道每一个产品对象的创建细节，并决定何时实例化哪一个产品类。简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，需要在其中加入必要的业务逻辑，这违背了“开闭原则”。此外，在简单工厂模式中，所有的产品都由同一个工厂创建，工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性，而工厂方法模式则可以很好地解决这一问题。

         在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构


- 定义

  > 定义一个用于创建对象的接口，让子类决定实例化哪一个类（类的实例化延迟到子类）

- 角色

  - **Product（抽象产品）：**它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类
  - **ConcreteProduct（具体产品）：**它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应
  - **Factory（抽象工厂）：**在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口
  - **ConcreteFactory（具体工厂）：**它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例

- 类图

  ![1590594224822](https://raw.githubusercontent.com/guchaolong/guchaolong.github.io/master/_posts_img/design_pattern/1590594224822.png)



  ### 


### 4、抽象工厂

- 概述

  工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。此时，我们可以考虑**将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产**，例如，数据库操作，需要获得Connection、Statement...对象，数据库有MySQL、Oracle等多种，可以定义MySQL的工厂可以生产MySQL的Connection、Statement对象，Oracle工厂生产Oracle的Connection、Statement对象

- 角色

  - **AbstractFactory（抽象工厂）：**它声明了一组用于创建一族产品的方法，每一个方法对应一种产品
  - **ConcreteFactory（具体工厂）：**它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中
  - **AbstractProduct（抽象产品）：**它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法
  - **ConcreteProduct（具体产品）：**它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法

- 类图

  ![1590595464496](https://raw.githubusercontent.com/guchaolong/guchaolong.github.io/master/_posts_img/design_pattern/1590595464496.png)

- 例子

  ```java
  /**
   * 抽象产品
   */
  public interface Connection {
      void connection();
  }
  
  /**
   * 抽象产品
   */
  public interface Statement {
      void statement();
  }
  
  /**
   * 抽象工厂
   */
  public interface ConnectionAndStatementFactory {
      Connection getCon();
  
      Statement getSta();
  }
  
  /**
   * 具体产品
   */
  public class MysqlConnection implements Connection {
      @Override
      public void connection() {
          System.out.println("MySQL connection");
      }
  }
  /**
   * 具体产品
   */
  public class MysqlStatement implements Statement {
      @Override
      public void statement() {
          System.out.println("MySQL statement");
      }
  }
  
  /**
   * 具体产品
   */
  public class OracleConnection implements Connection {
      @Override
      public void connection() {
          System.out.println("Oracle connection");
      }
  }
  
  /**
   * 具体产品
   */
  public class OracleStatement implements Statement {
      @Override
      public void statement() {
          System.out.println("Oracle statement");
      }
  }
  
  /**
   * 具体工厂
   */
  public class MysqlFactory implements ConnectionAndStatementFactory {
      @Override
      public Connection getCon() {
          return new MysqlConnection();
      }
  
      @Override
      public Statement getSta() {
          return new MysqlStatement();
      }
  }
  
  /**
   * 具体工厂
   */
  public class OracleFactory implements ConnectionAndStatementFactory {
      @Override
      public Connection getCon() {
          return new OracleConnection();
      }
  
      @Override
      public Statement getSta() {
          return new OracleStatement();
      }
  }
  
  /**
   * 调用方
   */
  public class Client {
      public static void main(String[] args) {
          //连接数据库，需要connection statement,我不关心怎么产生，给我我需要的就行
          ConnectionAndStatementFactory factory = new OracleFactory();//给你一个工厂（ConnectionAndStatementFactory里定义了相关方法）
          Connection con = factory.getCon();//通过工厂给你一个connection
          Statement sta = factory.getSta();//通过工厂给你一个statement
          con.connection();//Oracle connection
          sta.statement();//Oracle statement
      }
  }
  
  ```



### 5、建造者

- 定义

  将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示

- 场景

  - 构造函数的参数超过**4个**，且有些参数可选

    这种情况通常会通过**折叠构造函数模式**、或者**javabean**模式解决

    ```java
    /**
    
    - 在这种模式下，程序员会先提供一个只有必要参数的构造器，然后在这个构造器的基础上，提供一个还要需要有一个可选参数的构造器，接着提供一个需要有两个可选参数的构造器，以此类推，终于在最后一个构造器的参数列表里，不仅包含了那几个必要的参数，还包含了所有的可选参数。下面有个例子。为了简单起见，它只显示4个可选属性：
      */
    
    // Telescoping constructor pattern - does not scale well!
    public class NutritionFacts {
        private final int servingSize; // (mL) required 
        private final int servings;    // (per container) required
        private final int calories;    // (per serving) optional    
        private final int fat;         // (g/serving) optional
        private final int sodium;      // (mg/serving) optional
        private final int carbohydrate; // (g/serving) optional
        public NutritionFacts(int servingSize, int servings) { 
            this(servingSize, servings, 0);
        }
        public NutritionFacts(int servingSize, int servings, int calories) {
            this(servingSize, servings, calories, 0); 
        }
        public NutritionFacts(int servingSize, int servings, int calories, int fat) {
            this(servingSize, servings, calories, fat, 0); 
        }
        public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium) {
            this(servingSize, servings, calories, fat, sodium, 0); 
        }
        public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, 
            int carbohydrate) {
            this.servingSize = servingSize; this.servings = servings;
            this.calories = calories
            this.fat = fat
            this.sodium = sodium
            this.carbohydrate = carbohydrate;
        } 
    }
    
    //javabean模式，通过get/set方法，先调用默认的构造方法，在set
    public class Computer {
            ...
    
        public String getCpu() {
            return cpu;
        }
        public void setCpu(String cpu) {
            this.cpu = cpu;
        }
        public String getRam() {
            return ram;
        }
        public void setRam(String ram) {
            this.ram = ram;
        }
        public int getUsbCount() {
            return usbCount;
        }
    ...
    }
    ```

- Builder模式两种写法

  ```java
  public class Computer {
      private final String cpu;//必须
      private final String ram;//必须
      private final int usbCount;//可选
      private final String keyboard;//可选
      private final String display;//可选
  
      //2、私有化造函数，参数为Builder类型
      private Computer(Builder builder) {
          this.cpu = builder.cpu;
          this.ram = builder.ram;
          this.usbCount = builder.usbCount;
          this.keyboard = builder.keyboard;
          this.display = builder.display;
      }
  
      //1、静态内部类 Builder，然后将Computer 中的参数都复制到Builder类中
      public static class Builder {
          private String cpu;//必须
          private String ram;//必须
          private int usbCount;//可选
          private String keyboard;//可选
          private String display;//可选
  
          //3、Builder的构造函数，参数为Computer中必填的那些参数，cpu 和ram
          public Builder(String cup, String ram) {
              this.cpu = cup;
              this.ram = ram;
          }
  
          //4、设置函数，对Computer中那些可选参数进行赋值，返回值为Builder类型的实例
          public Builder setUsbCount(int usbCount) {
              this.usbCount = usbCount;
              return this;
          }
  
          public Builder setKeyboard(String keyboard) {
              this.keyboard = keyboard;
              return this;
          }
  
          public Builder setDisplay(String display) {
              this.display = display;
              return this;
          }
  
          //5、build()方法，调用私有构造方法，在其中构建Computer的实例并返回
          public Computer build() {
              return new Computer(this);
          }
      }
  }
  ```

  ```java
  public class Computer2 {
      private String cpu;//必须
      private String ram;//必须
      private int usbCount;//可选
      private String keyboard;//可选
      private String display;//可选
  
      //2、私有化造函数，只有内部类才能调用
      private Computer2() {
      }
  
      //1、静态内部类 Builder，然后将Computer 中的参数都复制到Builder类中
      public static class Builder {
          //3、持有一个外部类的属性，调用外部类构造函数
          Computer2 computer2 = new Computer2();
  
          //4、设置函数，对Computer中那些可选参数进行赋值，返回值为Builder类型的实例
          public Builder setCpu(String cpu) {
              computer2.cpu = cpu;
              return this;
          }
  
          public Builder setRam(String ram) {
              computer2.ram = ram;
              return this;
          }
  
          public Builder setUsbCount(int usbCount) {
              computer2.usbCount = usbCount;
              return this;
          }
  
          public Builder setKeyboard(String keyboard) {
              computer2.keyboard = keyboard;
              return this;
          }
  
          public Builder setDisplay(String display) {
              computer2.display = display;
              return this;
          }
  
          //5、build()方法
          public Computer2 build() {
              return computer2;
          }
      }
  }
  ```


## 结构型

### 1、适配器

- 定义

  将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，别名包装器（Wrapper)

- 类图

  有两种，类的适配器模式（使用继承）、对象的适配器模式（使用组合）

  区别：如果是继承方式，Adapter adapter = new Adapter之后，adapter既可以调用实现了的request()方法，也可以调用继承来的specificRequest()方法，但是在Adapter中specificRequest()是不应该出现的，根据迪米特法则，越少知道越好；使用组合，adapter对象就只能调实现了的request()

  ![1590935541531](https://raw.githubusercontent.com/guchaolong/guchaolong.github.io/master/_posts_img/design_pattern/1590935541531.png)

  ![1590935584590](https://raw.githubusercontent.com/guchaolong/guchaolong.github.io/master/_posts_img/design_pattern/1590935584590.png)

  - 目标接口（Target）:客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口
  - 需要适配的类（Adaptee）:需要适配的类
  - 适配器（Adapter）:通过包装一个需要适配的对象，把原接口转换成目标接口

- 使用

  - SpringMVC中的DispatcherServlet

    不同的请求会分发给不同的Handler,如HttpRequestHandler、Servlet、Controller

    其中HttpRequestHandler处理请求的方法是handleRequest(request, response)

    Servlet处理请求的方法是service(request, response)

    Controller处理请求的方法是handleRequest(request, response)

    所以DispatcherServlet获取到具体的Handler时，如果没有适配器，就只能判断类型，if-else

    有了适配器，把具体的处理器适配成HandlerAdapter，都以handle(request, response, handler)的方式调用，以上处理器的适配器分别对应HttpRequestHandlerAdapter、SimpleServletHandlerAdapter、SimpleControllerHandlerAdapter，它们三个都实现了HandlerAdapter，**这里的HandlerAdapter其实就是类图中的Target**

### 2、桥接

> 一个对象存在多个维度在变化

- 概述

  手机，按品牌，有华为、小米、OPPO、vivo等

  按内存，有16G 32G 64G

  这里如果每种手机都有一个实现，就需要4 * 3 = 12个具体类，况且这两个维度在变化的，桥接模式就是把这两个维度分离开来，每个维度都可以独立扩展

- 定义

  将抽象部分与它的实现部分分离，是他们都可以独立变化

- 说明

  以上面手机的例子，抽象部分就是品牌，实现部分是内存

- 类图

  ![1591111902502](https://raw.githubusercontent.com/guchaolong/guchaolong.github.io/master/_posts_img/design_pattern/1591111902502.png)

- 角色

  -  **Abstraction**：抽象类，聚合了一个Implementor,可以包含抽象或具体的业务方法
  -  **RefinedAbstraction**：扩充抽象类，实现了Abstraction中的抽象方法，也可调用implementor中的方法
  -  **Implementor**：实现类接口
  -  **ConcreteImplementor**：具体实现类

- 代码

  ```java
  /**
   * 第一步：定义Implementor，这里定义手机内存接口
   * 抽象部分-内存
   */
  public interface Memory {
      void addMemory();
  }
  
  /**
   * 第二步：定义ConcreteImplementor，这里指具体的内存
   * 实现部分-16G
   */
  public class Memory16G implements Memory {
      @Override
      public void addMemory() {
          System.out.println("手机安装16G内存");
      }
  }
  
  public class Memory32G implements Memory {
      @Override
      public void addMemory() {
          System.out.println("手机安装了32G内存");
      }
  }
  
  /**
   * 第三步：定义Abstraction手机抽象类
   */
  public abstract class Phone {
      //使用聚合的方式，把内存部分包含进来
      Memory memory;
  
      public Memory getMemory() {
          return memory;
      }
  
      public void setMemory(Memory memory) {
          this.memory = memory;
      }
  
      abstract void buyPhone();
  }
  
  /**
   * 第四步：定义Refined Abstraction（具体的手机品牌）
   */
  public class HuaWei extends Phone {
      @Override
      void buyPhone() {
          memory.addMemory();
          System.out.println("购买了华为手机，内存为" + getMemory());
      }
  }
  
  public class OPPO extends Phone {
      @Override
      void buyPhone() {
          memory.addMemory();
          System.out.println("购买了OPPO手机，内存为" + getMemory());
      }
  }
  
  /**
   * 使用
   */
  public class Client {
      public static void main(String[] args) {
          Memory memory = new Memory32G();
          Phone phone = new HuaWei();
          phone.setMemory(memory);
          phone.buyPhone();
      }
  }
  ```

  ![1591113820370](https://raw.githubusercontent.com/guchaolong/guchaolong.github.io/master/_posts_img/design_pattern/1591113820370.png)

### 3、组合

> 遇到树形结构就应该想到用组合模式解决

- 引入

  整体-部分：如衣柜-衣服、文件夹-文件

  抽象构件：一个抽象，容器和叶子的共同父类

  容器构件：具有“容器”特征的对象，充当普通对象的同时，又可以作为其他对象的容器（如文件夹）

  叶子构建：只能充当普通对象（如文件）

  子构件：容器对象A中,包含了另一个容器对象B，一级一个叶子对象C，那么B和C都称为A的子构件

  > 客户端在使用这种树形结构时，希望一致的处理他们，因为如果把容器对象和叶子对象区别对待，程序将会非常复杂
  >
  > 为了处理时具有一致性，通常在抽象构件中定义了共有业务方法，另外用于访问子构件的方法，如：add(),remove(),getChild()等方法，可以在抽象构件中定义，也可以在容器构件中定义，于是就有了透明组合模式和安全组合模式

- 定义

  组合多个对象形成树形结构以表示“整体-部分”的结构层次，组合模式对叶子对象和容器对象的使用具有一致性

  > 具有一致性之后，客户端处理时无需关心自己处理的是容器对象还是叶子 对象，简化了客户端代码

  核心：引入 一个抽象Component，它既是容器类（Composite)的父类，也是叶子类（Leaf）的父类

- 透明组合模式

  > 抽象构件中声明了所有用于管理成员对象的方法，包括add、remove()、getChild()等方法，
  >
  > 好处是：确保所有的构件类都有相同的接口，在客户端看来，叶子构件和容器构件所提供的方法是一致的，可以相同对待
  >
  > 缺点是：不够安全，叶子和容器本质上是有区别的，叶子对象里不可能再有下一层对象，因此add()等方法是没有意义的，编译不错但运行时可能出错

  ![1591200116053](https://raw.githubusercontent.com/guchaolong/guchaolong.github.io/master/_posts_img/design_pattern/1591200116053.png)

  ```java
  /**
   * 抽象构件
   * 透明组合模式 抽象构件中定义了所有方法，包括操作子构件的方法
   */
  public abstract class Component {
      //共有的业务逻辑方法
      public abstract void operation();
  
      //添加子构件
      public abstract void add(Component c);
  
      //移除子构件
      public abstract void remove(Component c);
  
      //获取子构件
      public abstract Component getChild(int i);
  }
  
  /**
   * 容器构件
   */
  public class Composite extends Component {
  
      //持有一个元素为抽象构件的list
      private List<Component> child = new ArrayList<>();
  
      //遍历list,客户端操作一个Component时，会迭代调用
      @Override
      public void operation() {
          for (Component obj : child) {
              obj.operation();
          }
      }
  
      @Override
      public void add(Component c) {
          child.add(c);
      }
  
      @Override
      public void remove(Component c) {
          child.remove(c);
      }
  
      @Override
      public Component getChild(int i) {
          return child.get(i);
      }
  }
  
  
  /**
   * 叶子 构件
   */
  public class Leaf extends Component {
      @Override
      public void operation() {
          System.out.println("叶子构件业务方法执行中...");
      }
  
      @Override
      public void add(Component c) {
          System.out.println("实际开发中，这里要进行异常处理或错误提示，叶子不支持add");
      }
  
      @Override
      public void remove(Component c) {
          System.out.println("实际开发中，这里要进行异常处理或错误提示，叶子不支持remove");
      }
  
      @Override
      public Component getChild(int i) {
          System.out.println("实际开发中，这里要进行异常处理或错误提示，叶子不支持getChild");
          return null;
      }
  }
  
  
  /**
   * 客户端调用
   */
  public class Client {
      public static void main(String[] args) {
          Component c1, c2, c3, c4;
          Composite s1, s2;
  
          c1 = new Leaf();
          c2 = new Leaf();
          c3 = new Leaf();
          c4 = new Leaf();
  
          s1 = new Composite();
          s2 = new Composite();
  
          s1.add(c1);
          s1.add(c2);
          s2.add(c3);
          s2.add(c4);
          s1.add(s2);
  
          //一致性，s1是Component的子类，无论它具体是什么类型，都有公共的operation方法
          s1.operation();
      }
  }
  
  ```

- 安全组合模式

  > 抽象构件中没有声明任何用于管理成员对象的方法，而是在容器构件中声明，这种做法是安全的
  >
  > 缺点是:不够透明，叶子和容器具有不同的方法，没有在抽象构件中定义，所以客户端不能完全针对抽象编程，并一致地使用叶子构件和容器构件

  ![1591200503847](https://raw.githubusercontent.com/guchaolong/guchaolong.github.io/master/_posts_img/design_pattern/1591200503847.png)

  ```java
  /**
   * 抽象构件
   * 安全组合模式：抽象构件中只定义公共的业务方法，
   * 操作子构件的add、remove、getChild等方法留到了容器构件中实现
   */
  public abstract class Component {
      //共有的业务逻辑方法
      public abstract void operation();
  }
  
  
  /**
   * 容器构件
   * 处理实现公共方法，还定义了操作子构件的方法
   */
  public class Composite extends Component {
  
      //持有一个元素为抽象构件的list
      private List<Component> child = new ArrayList<>();
  
      //遍历list,客户端操作一个Component时，会迭代调用
      @Override
      public void operation() {
          for (Component obj : child) {
              obj.operation();
          }
      }
  
      public void add(Component c) {
          child.add(c);
      }
  
      public void remove(Component c) {
          child.remove(c);
      }
  
      public Component getChild(int i) {
          return child.get(i);
      }
  }
  
  
  /**
   * 叶子 构件
   * 只需要实现抽象构件中定义的公共方法
   * 本来叶子构件就不应该包含add、remove等操作
   */
  public class Leaf extends Component {
      @Override
      public void operation() {
          System.out.println("叶子构件业务方法执行中...");
      }
  }
  
  //客户端还是一样
  ```

### 4、装饰

> 增加一个对象的功能，常见的就是继承它，然后在子类中增加方法，但是这种方法不具有灵活性，容易造成类爆炸，使用聚合的方式可以解决这个问题

- 定义

  动态地给一个对象增加一些额外的功能

- 类图

  ![1591285802382](https://raw.githubusercontent.com/guchaolong/guchaolong.github.io/master/_posts_img/design_pattern/1591285802382.png)

- 角色

  - Component(抽象构件)

    什么具体构件中实现的业务方法

  - ConcreteComponent(具体构件)

    实现了抽象构件中的业务方法，装饰器可以给他增加额外的职责（方法）

  - Decorator(抽象装饰类)

    维护一个抽象构件类型的引用（作为被装饰的构件），业务方法内调用该引用的业务方法，通过子类扩展该方法，以达到装饰的目的

  - ConcreteDecorator（具体装饰类）

    负责添加新的 职责

- 列子

  变形金刚，最初是汽车，可以变形（装饰）为机器人，就有了说话的功能，还可以装饰成飞机，具有飞翔功能，因为在结构上，装饰器是对抽象构件进行装饰，他们顶层抽象都属于抽象构件，所以，装饰成机器人之后还可以装饰成飞机

  ```java
  /**
   * 抽象构件-Component
   * 
   * 变形金刚
   */
  public interface Transform {
      //定义最基本的方法，无论怎么装饰，这个方法都会有,
      //即类图中的operator方法
      public void move();
  }
  
  
  /**
   * 具体构件类-ConcreteComponent
   * 被装饰的最初的对象
   */
  public class Car implements Transform {
      public Car() {
          System.out.println("原始对象：一辆汽车");
      }
  
      @Override
      public void move() {
          System.out.println("最初对象：只是一辆车子，在地上移动");
      }
  }
  
  
  /**
   * 抽象装饰器类-Decorator
   */
  public class Changer implements Transform {
      //聚合，维护一个指向抽象构件类型的引用（要被装饰的对象）
      private Transform transform;
  
      //构造方法
      public Changer(Transform transform) {
          this.transform = transform;
      }
  
      @Override
      public void move() {
          transform.move();//并未真正实现，而是调用被装饰对象的方法
      }
  }
  
  
  /**
   * 具体装饰类-ConcreteDecoratorA
   * 装饰成机器人
   */
  public class Robot extends Changer {
  
      public Robot(Transform transform) {
          super(transform);
          System.out.println("变成机器人");
      }
  
      //增加说话的功能
      public void say() {
          System.out.println("说话");
      }
  }
  
  
  /**
   * 具体装饰类-ConcreteDecoratorB
   * 装饰成飞机
   */
  public class Airplane extends Changer {
      public Airplane(Transform transform) {
          super(transform);
          System.out.println("变成飞机");
          fly();//
      }
  
      //增加飞翔功能
      public void fly() {
          System.out.println("飞翔");
      }
  }
  
  
  /**
   * 客户端使用
   */
  public class Client {
      public static void main(String[] args) {
          Transform t = new Car();//要被装饰的对象
          t.move();//最基本的方法
  
          Robot c = new Robot(t);//装饰成机器人
          c.move();
          c.say();//因为装饰成机器人了，有了说话的功能
  
          Airplane a = new Airplane(c);//装饰成飞机
          a.move();
          a.fly();
  
      }
  }
  ```


### 5、外观

> 当客户端完成一个操作需要跟多个对象交互时，如果没有一个统一的入口，就会跟这些对象耦合，提供一个统一的入口（一个外观对象），把具体操作的细节封装到这个外观对象中，客户端就只需要跟外观对象交互就行

- 定义

  为子系统的一组接口提供一个统一的接口，Facade模式就是定义一个高层接口，这个高层接口使得这一子系统更加容易使用

- 代码

  ```java
  /**
   * 子系统A
   */
  public class SubSystemA {
      public void doSomething() {
          System.out.println("subsystemA handling");
      }
  }
  
  /**
   * 子系统B
   */
  public class SubSystemB {
      public void doSomething() {
          System.out.println("subsystemB handling");
      }
  }
  
  /**
   * 子系统C
   */
  public class SubSystemC {
      public void doSomething() {
          System.out.println("subsystemC handling");
      }
  }
  
  /**
   * 客户端
   */
  public class Client {
      public static void main(String[] args) {
          doSomething();
      }
  
      public static void doSomething() {
          //没有统一的入口，这个方法需要和a、b、c三个子系统分别交互，耦合度高
          SubSystemA a = new SubSystemA();
          SubSystemB b = new SubSystemB();
          SubSystemC c = new SubSystemC();
          a.doSomething();
          b.doSomething();
          c.doSomething();
      }
  }
  
  
  /**
   * 外观类
   */
  public class Facade {
      public void doSomething() {
          //由外观类来和子系统交互，细节对客户端不可见
          SubSystemA a = new SubSystemA();
          SubSystemB b = new SubSystemB();
          SubSystemC c = new SubSystemC();
          a.doSomething();
          b.doSomething();
          c.doSomething();
      }
  }
  
  
  /**
   * 客户端
   */
  public class Client {
      public static void main(String[] args) {
          Facade facade = new Facade();
          facade.doSomething();
      }
  }
  ```

  ![1591372334404](https://raw.githubusercontent.com/guchaolong/guchaolong.github.io/master/_posts_img/design_pattern/1591372334404.png)



### 6、享元

- 定义

  运用**共享技术**有效地支持大量细粒度对象地复用

- 享元类的关键部分就是**享元工厂类**，维护一个共享池，用一个Map来存储对象，对象中可以共享的部分（即内部状态）作为key,定义一个获取对象的方法，方法里逻辑：如果存在该状态的对象，则直接返回，如果不存在则新建一个，put进map里，并返回该对象

- 例子

  五子棋，如果每下一步都需要new一棵棋子，会造成CPU和内存的浪费，其实棋子只有黑白两种，不同的只是落子的位置，这里的黑白是**内部状态**内部状态是可以共享的，位置是**外部状态**，外部状态不能共享

  因此把不能共享的外部状态分离出去，内部状态的对象就可以复用

  ```java
  /**
   * 享元类
   */
  public class Chess {
      //内部状态（可以共享的）
      private String color;
  
      //可以共享的内部状态 作为构造函数的参数
      public Chess(String color) {
          this.color = color;
      }
  
      //业务方法-在local位置落子
      public void operation(Local local) {
          System.out.println("棋子颜色：" + color + " 落子位置：" + local);
      }
  }
  
  
  /**
   * 外部状态-位置
   */
  public class Local {
      private int x;
      private int y;
  
      public Local(int x, int y) {
          this.x = x;
          this.y = y;
      }
  
      @Override
      public String toString() {
          return "Local{" +
                  "x=" + x +
                  ", y=" + y +
                  '}';
      }
  }
  
  
  /**
   * 享元工厂类
   */
  public class ChessFactory {
      private static ChessFactory INSTANCE;
  
      private ChessFactory() {
      }
  
      private ConcurrentHashMap<String, Chess> chessMap;//共享池
  
      //双重锁单例模式获取棋子工厂类
      public static ChessFactory getInstance() {
          if (INSTANCE == null) {
              synchronized (ChessFactory.class) {
                  if (INSTANCE == null) {
                      INSTANCE = new ChessFactory();
                  }
              }
          }
          return INSTANCE;
      }
  
      public Chess getChess(String color) {
          if (!chessMap.containsKey(color)) {
              chessMap.put(color, new Chess(color));
          }
          return chessMap.get(color);
      }
  }
  
  
  /**
   * 客户端使用
   */
  public class Client {
      public static void main(String[] args) {
          String black = "黑色";
          String white = "白色";
  
          ChessFactory factory = ChessFactory.getInstance();
          Chess chess = factory.getChess(black);
          chess.operation(new Local(1,2));
          Chess chess2 = factory.getChess(white);
          chess2.operation(new Local(3,5));
      }
  }
  ```


### 7、代理

- 动机

  一个客户不想或不能直接引用一个对象，可以通过一个称之为“代理”的第三者来实现间接引用

- 定义

  给某一个对象提供一个代理，并由代理对象控制对原有对象的引用

- 类图

  ![1591444432942](https://raw.githubusercontent.com/guchaolong/guchaolong.github.io/master/_posts_img/design_pattern/1591444432942.png)

- 例子

  明星Star，都有唱歌sing()、跳舞dance()的方法，具体明星对象有LiuDeHua、ZhouJieLun

  现在我要请刘德华给我唱歌，并且要在刘德华唱歌前记录开始时间，唱完后记录结束时间，我不能直接接触到刘德华，因此不能让刘德华自己去记录，怎么办呢，去找刘德华的经纪人，经纪人可以帮我记录时间

- 静态代理

  > 代理类（经纪人）是我自己生成的

  方案一：让经纪人继承刘德华，就有了唱歌跳舞的方法，我就可以在经纪人的这两个方法里记录时间，如果我不想记录时间了，我希望在唱歌前给我说句祝福语，那之前的经纪人就不行了，因为他是负责记录时间的，我就得重新找个经纪人2继承刘德华，再在这个经纪人2的方法里说祝福语...如果又有其他需求，又得新加经纪人，这样的话灵活性不够，会造成类爆炸

  方案二：让经纪人和刘德华都实现Star接口，并且经纪人持有一个Star类型的引用（被代理对象），真正唱歌的时候，调他持有的引用的方法，再加上自己的逻辑，这样的话，代理对象又可以作为被代理对象了

  ```java
  /**
   * 抽象主题角色-Subject
   * 申明了真实主题和代理主题的共同接口，这样依赖任何使用真实主题的地方都
   * 可以使用代理主题。
   * 客户端需要针对抽象主题角色进行编程
   */
  public interface Star {
      void sing();
      void dance();
  }
  
  /**
   * 真实主题角色-RealSubject
   * 实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实
   * 主题角色中定义的方法
   */
  public class LiuDeHua implements Star {
      @Override
      public void sing() {
          System.out.println("liu de hua sing...");
      }
      @Override
      public void dance() {
          System.out.println("liu de hua dancing");
      }
  }
  
  
  /**
   * 代理主题角色-Proxy
   * 时间代理类，包含了对真实主题角色的引用
   */
  public class LiuDeHuaTimeProxy implements Star {
      //被代理对象
      private Star star;
  
      public LiuDeHuaTimeProxy(Star star) {
          this.star = star;
      }
  
      @Override
      public void sing() {
          System.out.println("before time:" + System.currentTimeMillis());
          star.sing();
          System.out.println("end time:" + System.currentTimeMillis());
      }
  
      @Override
      public void dance() {
          System.out.println("before time:" + System.currentTimeMillis());
          star.dance();
          System.out.println("end time:" + System.currentTimeMillis());
      }
  }
  
  
  public class Client {
      public static void main(String[] args) {
          Star star = new LiuDeHua();
          Star proxy = new LiuDeHuaTimeProxy(star);
          proxy.sing();
          proxy.dance();
      }
  }
  
  
  输出：
  before time:1591444179499
  liu de hua sing...
  end time:1591444179499
  before time:1591444179499
  liu de hua dancing
  end time:1591444179499
  
  
  ```

- JDK动态代理

  > 需要被代理对象实现接口

  ```java
  /**
   * 增加一个抽象接口-演员
   */
  public interface Player {
      void play();
  }
  
  /**
   * 真实主题角色-RealSubject
   * 实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实
   * 主题角色中定义的方法
   */
  public class LiuDeHua implements Star, Player {
      @Override
      public void sing() {
          System.out.println("liu de hua sing...");
      }
      @Override
      public void dance() {
          System.out.println("liu de hua dancing");
      }
  
      @Override
      public void play() {
          System.out.println("liu de hua playing");
      }
  }
  
  
  public class Client2 {
      public static void main(String[] args) {
          Star star = new LiuDeHua();
          // 在工程中保存jdk生成的代理类
          System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");
          /**
           * 使用JDK动态代理生产动态代理类
           * Proxy.newProxyInstance
           * 第一个参数，classLoader 直接使用真实对象的classLoader就行
           * 第二个参数，实现的接口，
           * 第三个对象，调用处理，真正的逻辑就写在此处，还是调用真实对象的方法
           */
          Star o = (Star) Proxy.newProxyInstance(star.getClass().getClassLoader(), 
                  star.getClass().getInterfaces(),
                  new InvocationHandler() {
                      @Override
                      public Object invoke(Object o, Method method, Object[] objects) throws Throwable {
                          System.out.println("liu de hua " + method.getName() + " start, time:" + System.currentTimeMillis());
                          Object result = method.invoke(star, objects);
                          System.out.println("liu de hua " + method.getName() + " end, time:" + System.currentTimeMillis());
                          return result;
                      }
                  });
          o.sing();
          o.dance();
          Player p = (Player) o;
          p.play();
      }
  }
  ```


## 行为型

> 创建型关注对象的创建
>
> 结构型关注对象与类的组织
>
> 行为型关注对象之间的交互，不同对象之间划分责任和算法的抽象化

### 1、职责链

链式处理请求，将能够处理同一类请求的对象连成一条链，所提交的请求沿着链传递，链上的对象逐个判断是否又能力处理该请求，如果有则处理，如果不能则传递给下一个处理对象

```java
/**
 * 请求对象
 */
public class Request {
    private String state;

    public Request(String state) {
        this.state = state;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }
}


/**
 * 抽象处理类
 */
public abstract class AbstractHandler {
    //第一个handler
    public static AbstractHandler startHandler = new Handler1();
    //下一个handler
    private AbstractHandler nextHandler;

    //初始化处理链
    static {
        startHandler.setNextHandler(new Handler2())
                .setNextHandler(new Handler3());
    }

    //返回当前对象，可以链式调用
    private AbstractHandler setNextHandler(AbstractHandler handler) {
        this.nextHandler = handler;
        return this.nextHandler;
    }

    protected void commonLog() {
        System.out.println(this.getClass().getName());
    }

    protected boolean needHandle(Request request) {
        return true;
    }

    protected void handle(Request r) {
        if (this.nextHandler != null) {
            this.nextHandler.handle(r);
        }
    }
}


public class Handler1 extends AbstractHandler {

    @Override
    public boolean needHandle(Request request) {
        return request.getState().equals("handle1");
    }

    @Override
    protected void handle(Request request) {
        if(needHandle(request)){
            System.out.println("handler1 ...................");
            request.setState("handle2");
        }
        super.handle(request);
    }
}

public class Handler2 extends AbstractHandler {
    @Override
    public boolean needHandle(Request request) {
        return request.getState().equals("handle2");
    }

    @Override
    protected void handle(Request request) {
        if(needHandle(request)){
            System.out.println("handler2 ...................");
            request.setState("handle3");
        }
        super.handle(request);
    }
}

.....

public class Client {
    public static void main(String[] args) {
        Request req = new Request("handle1");
        AbstractHandler.startHandler.handle(req);
    }
}
```



![1591515126789](https://raw.githubusercontent.com/guchaolong/guchaolong.github.io/master/_posts_img/design_pattern/1591515126789.png)

### 2、命令

- 类图

  ![1591543946980](https://raw.githubusercontent.com/guchaolong/guchaolong.github.io/master/_posts_img/design_pattern/1591543946980.png)

  ![1591543917341](https://raw.githubusercontent.com/guchaolong/guchaolong.github.io/master/_posts_img/design_pattern/1591543917341.png)


### 3、解释器-略

### 4、迭代器

> 根据“单一职责原则”，对象承担的指责越少，则该对象的稳定性就越好，受到的约束就越少，复用也就越方便，职责分离的要点就是对被分离的职责进行封装，并以抽象的方式建立起彼此之间的关系，
>
> 聚合对象主要拥有两个职责：以实存储内部数据，而是遍历内部数据。但是前者是聚合对象的基本功能，而后者是可以分离的。因此，我们将遍历聚合对象中数据的行为提取出来，封装到一个迭代器中，通过专门的迭代器来遍历聚合对象的内部数据，这就是迭代器的本质，迭代器模式是“单一职责原则”的完美体现

- 定义

  提供一种方法来访问聚合对象，而不用暴露这个对象的内部结构，其别名为游标（Cursor)

- 类图

  ![1592113541199](https://raw.githubusercontent.com/guchaolong/guchaolong.github.io/master/_posts_img/design_pattern/1592113541199.png)

### 5、中介者-略

### 6、备忘录

> 提供对象的状态恢复机制

- 定义

  在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态

- 类图

  ![1592132852805](https://raw.githubusercontent.com/guchaolong/guchaolong.github.io/master/_posts_img/design_pattern/1592132852805.png)

- 实例 

​	Originator(原发器）
  ```java
  /**
   * Originator(原发器）
   * 需要被恢复某个状态的对象
   */
  public class UserInfoDTO {
      private String account;
      private String password;
      private String telNo;
  
      public Memento saveMemento(){
          return new Memento(account, password, telNo);
      }
  
      public void restoreMemento(Memento memento){
          this.account = memento.getAccount();
          this.password = memento.getPassword();
          this.telNo = memento.getTelNo();
      }
  
      public String getAccount() {
          return account;
      }
  
      public void setAccount(String account) {
          this.account = account;
      }
  
      public String getPassword() {
          return password;
      }
  
      public void setPassword(String password) {
          this.password = password;
      }
  
      public String getTelNo() {
          return telNo;
      }
  
      public void setTelNo(String telNo) {
          this.telNo = telNo;
      }
  
      @Override
      public String toString() {
          return "UserInfoDTO{" +
                  "account='" + account + '\'' +
                  ", password='" + password + '\'' +
                  ", telNo='" + telNo + '\'' +
                  '}';
      }
  }
  ```

Memento(备忘录）
  ```java
  /**
   * Memento(备忘录）
   * 存储原发器的内部状态，根据原发器来决定保存哪些内部状态
   */
  class Memento {
      private String account;
      private String password;
      private String telNo;
  
      public Memento(String account, String password, String telNo) {
          this.account = account;
          this.password = password;
          this.telNo = telNo;
      }
  
      public String getAccount() {
          return account;
      }
  
      public void setAccount(String account) {
          this.account = account;
      }
  
      public String getPassword() {
          return password;
      }
  
      public void setPassword(String password) {
          this.password = password;
      }
  
      public String getTelNo() {
          return telNo;
      }
  
      public void setTelNo(String telNo) {
          this.telNo = telNo;
      }
  }
  ```

Caretaker(负责人）
  ```java
  /**
   * Caretaker(负责人）
   * 负责人又称管理者，负责保存备忘录，但是不能对备忘录的内容进行操作或检查
   * 负责人中可以存储一个或多个备忘录对象，它只负责存储对象，不能修改对象，
   * 也无需知道对象的实现细节
   */
  public class Caretaker {
      private Memento memento;
  
      public Memento getMemento() {
          return memento;
      }
  
      public void setMemento(Memento memento) {
          this.memento = memento;
      }
  }
  ```

client
  ```java
  public class Client {
      public static void main(String[] args) {
          UserInfoDTO user = new UserInfoDTO();
          user.setAccount("oldAccount");
          user.setPassword("oldPassword");
          user.setTelNo("oldTelNo");
          System.out.println(user);
  
          Caretaker caretaker = new Caretaker();
          Memento memento = user.saveMemento();
          caretaker.setMemento(memento);
  
          user.setAccount("newAccount");
          user.setPassword("newPassword");
          user.setTelNo("newTelNo");
          System.out.println(user);
  
          user.restoreMemento(caretaker.getMemento());
          System.out.println(user);
      }
  }
  ```

### 7、观察者

- 定义

  定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并自动更新

  > 又叫
  >
  > 发布-订阅（Publish/Subscribe)
  >
  > 模型-视图（Model/View)
  >
  > 源-监听器（Source/Listener)

- 类图

  ![1592135095241](https://raw.githubusercontent.com/guchaolong/guchaolong.github.io/master/_posts_img/design_pattern/1592135095241.png)


### 8、状态

> 根据状态决定行为

根据不同的状态有不同的操作，如果不适用状态模式，普通的方法就是if...else或者switch,这样的话如果增加某个状态就要修改源代码，违反开闭原则，利用状态模式，就是把具体的操作封装的某个状态类里面，调用处聚合抽象状态类就行

- 定义

  允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类

- 类图

  ![1592139572902](https://raw.githubusercontent.com/guchaolong/guchaolong.github.io/master/_posts_img/design_pattern/1592139572902.png)

- 角色

  - Context(环境类)：上下文类，它是拥有状态的对象，状态存在多样性且在不同的状态下，对象的行为有所不同，因此将状态独立出去形成单独的状态类，在环境类中维护一个抽象状态类State的实例，这个实例定义当前的状态
  - State(抽象状态类)：用于定义一个接口以封装与环境类的一个特定状态相关的行为，在抽象状态中申明了各种不同状态对应的方法，而在其子类中实现这些方法，由于不同状态下对象的行为可能不同，因此在不同子类中方法的实现可能存在不同，相同的方法可以卸载抽象状态类中
  - ConcreteState(具体状态类)：每一个子类实现一个与环境类的一个状态相关的行为

### 9、策略

- 定义

  准备一组算法，并将每一个算法封装起来，使得它们可以互换

- 类图

  ![1590503244545](https://raw.githubusercontent.com/guchaolong/guchaolong.github.io/master/_posts_img/design_pattern/1590503244545.png)

- 角色

  - **环境(Context)角色：** 持有一个Strategy的引用
  - **抽象策略(Strategy)角色：** 这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口
  - **具体策略(ConcreteStrategy)角色：** 包装了相关的算法或行为

- 应用

  一个鸭子类Duck，它的子类继承Duck，就能继承到父类的方法（代码重用），但是并非所有的方法都应该继承，比如有一个方法fly()，子类的这个方法有不同的实现，甚至有的子类比如塑料鸭不会飞，这样的话就要在子类中重写，这样会出现大量的类，在这个类中变化的部分是fly()，可以把这部分封装起来，定义一个接口FlyBehavior，然后有不同的实现，Duck类中持有一个FlyBehavior引用


  做一件事有多种方法，普通的写法就是if-else或switch，这样的话代码耦合度太高了，新加一种方法就要修改if-else\switch，违反了开闭原则，于是封装具体的算法，放到算法的上下文Context中（持有Strategy引用），这个Context起到了承上启下的作用，就像鸭子类，fly()属于鸭子；出行有多种出行方式，出行是游客的行为，所以Context就是游客

- JDK或Spring中的应用

  实现Comparator接口，可以定义不同的比较器，Arrays.sort(T[] a, Comparator<? super T> c)



### 10、模板方法

- 定义

  定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤

- 类图

  ![1592140914519](https://raw.githubusercontent.com/guchaolong/guchaolong.github.io/master/_posts_img/design_pattern/1592140914519.png)


### 11、访问者-略



