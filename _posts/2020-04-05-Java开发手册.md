---
layout:     post
title:      Java开发手册 
subtitle:   知识积累
date:       2020-04-05
author:     guchaolong
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
category: Java
tags:
       - Java
---

[TOC]

# Java开发手册

***



## 一、编程规约

### 命名

1. 不以_或**$**开头或结尾

2. 禁止英文+**拼音**混合，alibaba、taobao、youku、hangzhou等**国际通用**的可视为英文

3. **包名小写**，点**分隔符键有且仅有一个自然语义**的英文单词，包名都是**单数**形式，类名如果有复数含义，类名可以使用如数形式，如**MessageUtils**

4. **接口**中public也不要加，加上javadoc注释，尽量不要在接口中定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量

   ~~~
   String COMPANY = "alibaba";
   void f();
   ~~~

5. 枚举，带上**Enum后缀**，枚举成员名称**全大写**，单词间用**下划线**隔开，枚举其实就是特殊的常量类，且构造方法默认强制是私有,如DealStatusEnum

6. **抽象类**，**Abstract**或**Base**开头、异常类名以**Exception**结尾、测试类以原类名+**Test**结尾

7. **类名**，除领域模型相关的如 **DO、BO、DTO、VO**等例外，另外**XML、TCP、UDP**等也只是首字母大写

   ~~~
   UserDO、XmlService、TcpUdpDeal
   ~~~

8. **类名中体现设计模式**，如OrderFactory; LoginProxy; ResourceObserver;

9. 接口和实现类

   1. 对于Service和DAO类，基于SOA的理念，暴露出来的服务一定是接口，内部实现类用**Impl的后缀**与接口区别，如CacheServiceImpl implements CacheService
   2. 如果是**形容能力**的接口名称，去对应的形容词做接口名（通常是**-able**的形式），如AbstractIranslator implements Translatable

10. **常量**，全部**大写**，单词间用**下划线**隔开，力求表达完整清楚，不嫌长

11. **数组**定义：String [] args;

12. POJO类中**布尔类型变量**，不加**is**,因为部分框架解析会引起序列号错误

13. **缩写**要规范

14. 各层命名规约

    1. Service/DAO层方法前缀
       1. 获取单个对象 **get**
       2. 获取多个对象 **list**
       3. 获取统计值**count**
       4. 插入 **save**(推荐)或**insert**
       5. 删除 **remove**(推荐)或**delete**
       6. 修改 **updaet**
    2. 领域模型
       1. 数据对象：xxxDO,xxx即为数据表名
       2. 数据传输对象：xxxDTO,xxx为业务领域相关的名称
       3. 展示对象：xxxVO,xxx一般为网页名称
       4. POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO



### 常量定义

1. 不允许出现任何魔法值（即未经定义的常量）

   ~~~
   反例
   String key = "Id#taobao_" + tradeId;
   ~~~

2. long或Long赋值，用大写的L

3. 不要使用一个常量类维护所有常量，应该按功能进行归类，分开维护，如 缓存相关的CacheConsts、系统配置相关的ConfigConsts

### 格式规约

1. 左括号和后一个字符间不加空格，通用，右括号和前一个字符间也不加空格

2. if/else/for/while/switch/do等**保留字**与**左右括号之间**都必须加空格

3. **运算符**前后必须加一个空格 （赋值=、逻辑&&、+ - * /、三目等）

4. 单行字符数限制不超过120个（包括空格），IDEA中的竖线，如需要换行

   * **运算符**与下文一起换行
   * 方法调用的**点符号**与下文一起换行
   * 多个参数超长，**逗号后换行**
   * **不在括号前换行**

   ~~~
   String sb = new StringBuffer();
   sb.append("zi").append("xin")...
   	.append("huang")...
   	.append("huang")...
   	
   反例
   //括号前换行
   sb.append("zi").append("xin")...append
   	("huang")
   //逗号前换行
   method(args1, args2, ...
   	, argsx)
   ~~~

5. 方法体内的执行语句组、变量定义语句组、不同的业务逻辑之间或**不同的语义之间插入一个空行**，相同业务逻辑和语义之间不需要插入空行



### OOP规约

1. 静态变量或静态方法，用**类名访问**，用对象访问只是无谓增加编译器解析成本

2. 对外暴露的**接口签名**，原则上**不允许修改**，避免接口的调用方产生影响，接口过时必须加@Deprecated注解

3. 使用常量或确定有值的对象来调用equals,推荐使用java.util.**Objects#equals**

4. 所有**包装类型对象比较**使用equals方法（Integer在-128至127之间，赋值时使用缓存中的同一份，这个区间才可以用==）

5. 基本数据类型和包装数据类型

   1. **类**属性使用包装类型，数据库的查询结果可能为null,如果用基本数据类型接收，需要自动拆箱，有NPE风险
   2. pgc方法的**返回值和参数**必须使用包装数据类型
   3. **局部变量**推荐基本数据类型

6. 不要修改**serialVersionUID**字段，不一致会抛出序列化运行时异常

7. **构造方法**中禁止加入任务业务逻辑，如果有初始化逻辑，放**init**方法中

8. 类内方法定义顺序：public方法或pretected方法  >  私有方法  >  getter/setter方法

   ~~~
   公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关系，也可能是“模板设计模式”下的核心方法；私有方法外部一般不需要特别关心，是一个黑盒实现；因为方法信息价值低，所有Service和DAO的getter/setter方法在最后
   ~~~

9. 循环体内，字符串的连接方式，使用StringBuilder的append()方法进行扩展

10. final可提高程序的相应效率

### 集合处理

1. 只要重写equals就必须重写hashCode

2. ArrayList的subList结果不可强转为ArrayList

3. 集合转数组，必须使用集合的toArray(T[] array)

   ~~~
   List<String> list = new ArrayList<String>(2)；
   list.add("guan");
   list.add("bao");
   String[] array = new String[list.size()];
   array = list.toArray(array);
   ~~~

4. 使用Arrays.asList()把数组转成集合时，不能使用修改集合的方法，他的add/remove/clear方法会抛出UnsupportedOperationException异常

   ```
   asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法，Arrays.asList体现的时适配器模式，只是转换了接口，后台的数据仍是数组
   ```

5. 不要在foreach循环里进行remove/add操作。remove元素请使用Iterator方式，如果是并发操作，需要对Iterator对象加锁

6. 集合初始化时，精良指定集合初始值大小

7. 遍历Map使用entrySet，而不是keySet方式进行遍历

   ```
   keySet其实是遍历了2次，一次是转为Iterator对象，另一次是从hashMap中取出key所对应的value。而entrySet只是遍历了一次就把key和value都放到了entry中，效率更高，JDK8则使用Map.foreach方法
   ```

8. 利用Set元素唯一的特性，可以快速对一个集合进行去重操作，避免使用List的contains方法进行遍历、对比、去重操作

### 并发处理

1. 获取单例对象需要保证线程安全，其中的方法也要保证线程安全

   ```
   资源驱动类、工具类、单例工厂类都需要主意
   ```

2. 创建线程或线程池时指定有意义的线程名称

   ```
   public class TimerTaskThred extends Thred{
       ...
   }
   ```

3. 线程资源必须通过线程池提供，不允许在应用中自行显示创建线程

   ```
   使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决系统资源不足的问题。如果不适用线程池，有可能造成系统创建大量同类线程而导致线程消耗完内存或者“过度切换”的问题
   ```

4. 线程池不允许使用Executors去创建，二十通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险

   ```
   Executors返回的线程池对象的弊端如下
   1. FixedThreadPool和SingleThreadPool;
   	允许的请求队列长度为Integer.MAX_VALUE,可能会堆积大量的请求，从而导致OOM
   2. CachedThreadPool和ScheduledThreadPool
   	允许的创建线程数量为Integer.MAX_VALUE,可能会创建大量的线程，从而导致OOM
   ```

5. SimpleDateFormat是线程不安全得嘞，一般不要定义为static变量，如果定义为static，必须加锁，或者使用DateUtils工具类，JDK8,可以使用Instant代替Date, LocalDateTime代替Calendar,DateTimeFormatter代替SimpleDateFormatter

6. 高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁

7. 对多个资源、数据库、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁

   ```
   线程1需要对表A、B、C依次全部加锁后才可以进行更新操作，那么线程2的加锁顺序也必须时A、B、C
   ```

8. 并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用version作为更新依据

   ```
   如果每次访问冲突概率小于20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3次
   ```

9. 使用CountDownLatch进行异步转同步操作，每个线程推出前必须调用countDown方法，线程执行代码主意catch异常，确保countDown方法可以执行，避免主线程无法执行至countDown方法，知道超时才返回结果

   注意：子线程抛出异常堆栈，不能在主线程try-catch到

10. 避免Random实例被多线程使用，虽然共享该实例时线程安全的，但会因竞争同一seed导致性能下降

11. volatile解决多线程内存不可见问题，对于一写多读，是可以解决变量同步问题，但是如果多谢，同样无法解决线程安全问题。如果时count++操作哦，使用如下类

    ```
    AtomicInteger count = new AtomicInteger();
    count.addAndGet(1);
    
    JDK8
    推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）
    ```

12. HashMap在容量不够进行resize时由于高并发可能出现死锁，导致CPU飙升，在开发过程中注意规避此风险

13. ThreadLocal无法解决共享对象的更新问题，ThreadLocal对象建议使用static修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象（只要是这个线程内定义的）都可以操控这个变量



