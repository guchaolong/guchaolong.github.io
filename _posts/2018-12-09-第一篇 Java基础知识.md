---
layout:     post
title:      Java基础知识 
subtitle:   知识积累
date:       2018-12-09
author:     guchaolong
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
category: Java
tags:
       - Java
---

>掌握好java的基础知识



1. ## 基础知识
    #### 类型转换
    
        byte b1=3,b2=4,b;  
        b=3+4;//3和4都是常量，所以java在编译时期会检查该常量的和是否超出byte类型的范围。如果没有可以赋值  
        b=b1+b2;//编译出错,因为b1和b2是变量，因为变量的值会变化，不确定具体的值，所以默认使用int类型进行存储
        b1 = b1 +1;//出错，b1是变量，会转换为int类型  
        b1 += 1; //可以完成自动类型转换

2. ## 集合  
    数组，但是初始化之后尺寸固定，只能通过索引取出，所以要用到集合，删除某个元素之后，需要移动
    后续元素  

    1. Collection 集合类的跟接口
        - List 有序可重复
        - Set 无序 不可重复

    2. Map 键值对

    3. queue

      先进先出，跟排队一样，在队尾加入，队头处理完就移除


       方法： 

      ```
      add     添加                     如果队列已满，则抛出一个IIIegaISlabEepeplian异常
      remove  移除并返回头部的元素     如果队列为空，则抛出一个NoSuchElementException异常
      offer   添加并返回true           如果队列已满，则返回false  
      
      poll    移除并返问队列头部的元素 如果队列为空，则返回null  
      
      element 返回队列头部的元素       如果队列为空，则抛出一个NoSuchElementException异常
      
      peek    返回队列头部的元素       如果队列为空，则返回null
      
      put     添加一个元素             如果队列满，则阻塞
      
      take    移除并返回队列头部的元素 如果队列为空，则阻塞
      ```

        

       PriorityQueue<E>的出队顺序于元素的优先级有关,相当于VIP客户   

       在获取队首元素时 总是获取优先级最高的元素(放入队列中的元素必须实现Comparable接口)
       或者new PriorityQueue<>(new Comparator<T>(...那么类就不用实现Comparable接口了  

       Deque<E> 双端队列（double ended queue)  
       添加 可以到队首 也可以到队尾
       删除 也是  
       使用Deque<E>时 总是调用xxxFirst()/xxxLast()以便和Queue方法区分开  

       实现类有ArrayDeque和LinkedList  

       Deque<String> obj = new LinkedList<>();  
       在使用时，总是用特定的接口引用它，这是为了使代码的抽象层次更高，接口本身定义的方法
       代表了特定的用途  
       如果是LinkedList<String> obj = new LinkedList<>();obj.offerLast();这就很难看出这里的对象用途
       是一个Deque,如果是把LinkedList作为List使用，就应该是List<String> list = new LinkedList<>()
       ,可见，面向对象编程它的一个原则就是尽量持有接口，而不是实现类

3. ## IO
    输入（input）：把数据读到内存，如读硬盘上某个文件 从网络读取  
    输出（output）：从内存输出到外部，如写到硬盘上的某个文件  
    IO流：二进制数据最小以byte（字节流）为单位；字符流传输的最小数据单位时char,字符流输出的byte取决于编码方式  
    同步IO:读写时等待数据返回 才能执行后续代码；编写简单 CPU效率低（JDK的java.io是同步IO）  
    异步IO:读写IO发出请求，然后立刻执行后续代码；编写复杂 CPU执行效率高（JDK的java.nio是异步IO）  

    FileInputStream  
    ​    int read():读取下一个字节，并返回改字节对应的int值（0-255）,末尾-1
    ​    int read(byte [] b):读取若干字节到数组b中，返回读取的字节数  
    FileOutputStream  
    ​    write(byte[] b):写入b中的所有字节  
    ​    write(byte[] b,int off,int len):写入b指定范围的字节  
    ​    void flush():将缓冲区的内容输出  
    ​    
    把项目依赖的资源放在classpath中可以避免文件路径的依赖（相对路径）  
    Class对象的getResourceAsStream("")可以从classpath中读取资源（需要检查返回的stream是否为null）  

    序列化  
    把一个java对象变成二进制内容（byte[]），然后就可以把该数组保存在文件中 或在网络中传输

4. ## Java异常处理

5. ## Java反射与泛型
    > **java的反射机制是框架设计的灵魂，反射是框架的基础** 

    1. ### 反射
        java运行状态下，对于任意一个类，都能知道类的属性和方法；对于任意一个对象，都能调用它的任意属性和方法
        ，这种动态获取信息和动态调用对象方法的机制叫做反射     

    1. ### jvm 编译 运行         
        + 方法区：存放静态变量，静态方法，类代码信息，和常量，方法区是特殊的堆  

            类的加载：运行一个程序的时候，JVM启动，运行启动类加载器：bootstrap classloader
        用于加载java核心API（ExtClassLoader和AppClassLoader也在此时被加载），然后ExtClassLoader
        加载扩展API,AppClassLoader加载classpath下的API  

            在编译时.java文件被编译器编译成.class文件        
        
            运行时，启动jvm进程，jvm从classpath路径下寻找并加载.class文件，将**类的类型信息**加载到**方法区**  
        然后，在堆里创建代表这个类的java.lang.class对象（每个类的Class对象都只有一个，jvm对每个类都只会加载一次），作为方法区中类信息的访问入口，我们使用反射得到的那个class对象就是这个，它相当于一面镜子，映射出方法区中该类的信息
        
            Class对象是jvm创建的
        
            jvm为每个加载的类创建对应的Class实例，在该实例中保存了类的所有信息
        通过Class
        
            通过Class实例获取类信息的方法叫做反射
          
            利用JVM动态加载class的机制，可以在运行期间根据条件加载不同的实现类

            main方法执行时会在栈里形成main方法栈，栈里的元素是栈帧，一个方法对应一个栈帧，如果main方法调用了其他方法  
        ，会挨个往里压
        
    2. ### 三种方式
        ```
        Class c1 = Student.class;//知道类名

        Student student = new Student();
        Class c2 = student.getClass();//知道对象名

        Class c3 = Class.forName("com.guchaolong.javalearn.chapter04_reflect.Student");
        ```
    4. ### 泛型
        + 1.引出 

            ```
                    List list = new ArrayList();
                    list.add("sdf");
                    list.add(12);
                    for (Object o : list){
                        String a = (String)o;
                    }
            ```
            ArrayList底层使用数组存储元素，元素的类型是Object,如果把不同类型的对象放进去，取出来的时候就不知道
            具体是哪个类型，会报类型转换异常，使用ArrayListM<String>之后，就只能放入String类型的对象
            
            Object类是所有类的根类，所以都可以向上转换为Object类型的引用，使用的时候再向下转换，运行期间可能报转换异常，
            但是使用了泛型标识之后，在实际使用时，类型就已经确定了，不需要在进项强制类型转换

        + 2.特性

            泛型只在编译期有效，编译之后会进行类型擦除（编译期间正确检验泛型结果后，将泛型相关信息擦除）
            ```
            List<String> l1 = new ArrayList<String>();
            List<Integer> l2 = new ArrayList<Integer>();
            System.out.println(l1.getClass().equals(l2.getClass()));//true
            ```
        + 3.泛型的使用-泛型类 泛型接口 泛型方法 通配符
          ​          
            ```
            /**定义泛型类
             * T也可以写成其他,泛型也叫做参数化类型，这里的T就相当于一个形式参数
             * 在实例化这个泛型类的时候再指定实际类型，（实际参数）
             */
            public class Generic<T> {
            
                //key这个成员变量的类型为T,T的类型由外部指定
                private T key;
            
                public Generic(T key) {
                    this.key = key;
                }
                
                //虽然在方法中使用了泛型，但是这并不是一个泛型方法。
                //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。
                //所以在这个方法中才可以继续使用 T 这个泛型。
                public T getKey() {
                    return key;
                }
                public void setKey(T key) {
                    this.key = key;
                }
            }
            
                    Generic g0 = new Generic("DS");//如果不指定，就起不到类型检查的作用，会按Object处理
                    Generic<String> g1 = new Generic<>("df");
                    System.out.println(g1.getKey());
                    Generic<Integer> g2 = new Generic<>(12);
            ```
            ```
            public interface Generator<T> {
                T next();
            }
            /**
             * 未传入泛型实参时(还是T), 实现类后面必须要有<T> 否则报错
             */
            public class FruitGenerator<T> implements Generator<T> {
                @Override
                public T next() {
                    return null;
                }
            }
            //传入泛型实参（String)
            public class FruitGenerator implements Generator<String> {
                @Override
                public String next() {
                    return null;
                }
            }

            ```
            ```
                static void f1(Generic<Number> n){
                    System.out.println(n.getClass());
                }
                
                Generic<Number> n1 = new Generic<>(1);
                f1(n1);
                Generic<Integer> n2 = new Generic<>(2);
                f1(n2);//会报错,f1()接口的类型时Generic<Number> n 这是就需要通配符
                
                //这里的？就是通配符，在这里时类型实参，和String Number 这些一样 是实际的类型
                static void f2(Generic<？> n){
                   System.out.println(n.getClass());
                }
                f2(n1)；
                f2(n2)；
            ```
            泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型
            
            ```
            //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。
                    //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。
                    //所以在这个方法中才可以继续使用 T 这个泛型。
                    public T getKey(){
                        return key;
                    }
            
                    /**
                     * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E"
                     * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。
                    public E setKey(E key){
                         this.key = keu
                    }
                    */
                }
            
                /** 
                 * 这才是一个真正的泛型方法。
                 * 首先在public与返回值之间的<T>必不可少，这表明这是一个泛型方法，并且声明了一个泛型T
                 * 这个T可以出现在这个泛型方法的任意位置.
                 * 泛型的数量也可以为任意多个 
                 *    如：public <T,K> K showKeyName(Generic<T> container){
                 *        ...
                 *        }
                 */
                public <T> T showKeyName(Generic<T> container){
                    System.out.println("container key :" + container.getKey());
                    //当然这个例子举的不太合适，只是为了说明泛型方法的特性。
                    T test = container.getKey();
                    return test;
                }
            
                //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic<Number>这个泛型类做形参而已。
                public void showKeyValue1(Generic<Number> obj){
                    Log.d("泛型测试","key value is " + obj.getKey());
                }
            
                //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?
                //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类
                public void showKeyValue2(Generic<?> obj){
                    Log.d("泛型测试","key value is " + obj.getKey());
                }
            
                 /**
                 * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' "
                 * 虽然我们声明了<T>,也表明了这是一个可以处理泛型的类型的泛型方法。
                 * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。
                public <T> T showKeyName(Generic<E> container){
                    ...
                }  
                */
            
                /**
                 * 这个方法也是有问题的，编译器会为我们提示错误信息："UnKnown class 'T' "
                 * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。
                 * 所以这也不是一个正确的泛型方法声明。
                public void showkey(T genericObj){
            
                }
                */
            
            ```
        + 泛型上下边界
            使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类
            ```
            //上边界，<? extends T> 即传入的类型实参必须是指定类型的子类型
            <? extends Number> obj)
            
            //下边界 ：<? super T>  
            <? super Number> obj)  
            ```
           ```
        + 符号
        
            E - Element (在集合中使用，因为集合中存放的是元素)  
            T - Type（Java 类）                    
            K - Key（键）                    
            V - Value（值）                    
            N - Number（数值类型）                 
            ？ -  表示不确定的java类型
            
        
        
           ```
