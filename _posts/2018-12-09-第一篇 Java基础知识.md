---
layout:     post
title:      第一篇 Java基础知识 
subtitle:   知识积累
date:       2018-12-09
author:     guchaolong
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
category: Java
tags:
       - Java
---

>掌握好java的基础知识



1. # Java快速入门

2. # Java面向对象编程

3. # Java异常处理

4. # Java反射与泛型
    > **java的反射机制是框架设计的灵魂，反射是框架的基础** 
    
    1. ## 反射
        java运行状态下，对于任意一个类，都能知道类的属性和方法；对于任意一个对象，都能调用它的任意属性和方法
        ，这种动态获取信息和动态调用对象方法的机制叫做反射     
    
    1. ## jvm 编译 运行 
        ![](https://github.com/guchaolong/guchaolong.github.io/blob/master/_posts/2018-12-9-jvm.jpg)  
              
        + 方法区：存放静态变量，静态方法，类代码信息，和常量，方法区是特殊的堆  

            类的加载：运行一个程序的时候，JVM启动，运行启动类加载器：bootstrap classloader
        用于加载java核心API（ExtClassLoader和AppClassLoader也在此时被加载），然后ExtClassLoader
        加载扩展API,AppClassLoader加载classpath下的API  
 
            在编译时.java文件被编译器编译成.class文件        
        
            运行时，启动jvm进程，jvm从classpath路径下寻找并加载.class文件，将**类的类型信息**加载到**方法区**  
        然后，在堆里创建代表这个类的java.lang.class对象（每个类的Class对象都只有一个，jvm对每个类都只会加载一次），作为方法区中类信息的访问入口，我们使用反射得到的那个class对象就是这个，它相当于一面镜子，映射出方法区中该类的信息
        
            Class对象是jvm创建的
      
            jvm为每个加载的类创建对应的Class实例，在该实例中保存了类的所有信息
        通过Class
        
            通过Class实例获取类信息的方法叫做反射
       
            利用JVM动态加载class的机制，可以在运行期间根据条件加载不同的实现类
     
            main方法执行时会在栈里形成main方法栈，栈里的元素是栈帧，一个方法对应一个栈帧，如果main方法调用了其他方法  
        ，会挨个往里压
        
    2. ## 三种方式
        ```
        Class c1 = Student.class;//知道类名

        Student student = new Student();
        Class c2 = student.getClass();//知道对象名

        Class c3 = Class.forName("com.guchaolong.javalearn.chapter04_reflect.Student");
        ```
    3. ## 泛型
        + 1.引出 
        
            ```
                    List list = new ArrayList();
                    list.add("sdf");
                    list.add(12);
                    for (Object o : list){
                        String a = (String)o;
                    }
            ```
            ArrayList底层使用数组存储元素，元素的类型是Object,如果把不同类型的对象放进去，取出来的时候就不知道
            具体是哪个类型，会报类型转换异常，使用ArrayListM<String>之后，就只能放入String类型的对象
            
            Object类是所有类的根类，所以都可以向上转换为Object类型的引用，使用的时候再向下转换，运行期间可能报转换异常，
            但是使用了泛型标识之后，在实际使用时，类型就已经确定了，不需要在进项强制类型转换
        
        + 2.特性
        
            泛型只在编译期有效，编译之后会进行类型擦除（编译期间正确检验泛型结果后，将泛型相关信息擦除）
            ```
            List<String> l1 = new ArrayList<String>();
            List<Integer> l2 = new ArrayList<Integer>();
            System.out.println(l1.getClass().equals(l2.getClass()));//true
            ```
        + 3.泛型的使用-泛型类 泛型接口 泛型方法 通配符
                    
            ```
            /**定义泛型类
             * T也可以写成其他,泛型也叫做参数化类型，这里的T就相当于一个形式参数
             * 在实例化这个泛型类的时候再指定实际类型，（实际参数）
             */
            public class Generic<T> {
            
                //key这个成员变量的类型为T,T的类型由外部指定
                private T key;
            
                public Generic(T key) {
                    this.key = key;
                }
                
                //虽然在方法中使用了泛型，但是这并不是一个泛型方法。
                //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。
                //所以在这个方法中才可以继续使用 T 这个泛型。
                public T getKey() {
                    return key;
                }
                public void setKey(T key) {
                    this.key = key;
                }
            }
            
                    Generic g0 = new Generic("DS");//如果不指定，就起不到类型检查的作用，会按Object处理
                    Generic<String> g1 = new Generic<>("df");
                    System.out.println(g1.getKey());
                    Generic<Integer> g2 = new Generic<>(12);
            ```
            ```
            public interface Generator<T> {
                T next();
            }
            /**
             * 未传入泛型实参时(还是T), 实现类后面必须要有<T> 否则报错
             */
            public class FruitGenerator<T> implements Generator<T> {
                @Override
                public T next() {
                    return null;
                }
            }
            //传入泛型实参（String)
            public class FruitGenerator implements Generator<String> {
                @Override
                public String next() {
                    return null;
                }
            }

            ```
            ```
                static void f1(Generic<Number> n){
                    System.out.println(n.getClass());
                }
                
                Generic<Number> n1 = new Generic<>(1);
                f1(n1);
                Generic<Integer> n2 = new Generic<>(2);
                f1(n2);//会报错,f1()接口的类型时Generic<Number> n 这是就需要通配符
                
                //这里的？就是通配符，在这里时类型实参，和String Number 这些一样 是实际的类型
                static void f2(Generic<？> n){
                   System.out.println(n.getClass());
                }
                f2(n1)；
                f2(n2)；
            ```
            泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型
            
            ```
            //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。
                    //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。
                    //所以在这个方法中才可以继续使用 T 这个泛型。
                    public T getKey(){
                        return key;
                    }
            
                    /**
                     * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E"
                     * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。
                    public E setKey(E key){
                         this.key = keu
                    }
                    */
                }
            
                /** 
                 * 这才是一个真正的泛型方法。
                 * 首先在public与返回值之间的<T>必不可少，这表明这是一个泛型方法，并且声明了一个泛型T
                 * 这个T可以出现在这个泛型方法的任意位置.
                 * 泛型的数量也可以为任意多个 
                 *    如：public <T,K> K showKeyName(Generic<T> container){
                 *        ...
                 *        }
                 */
                public <T> T showKeyName(Generic<T> container){
                    System.out.println("container key :" + container.getKey());
                    //当然这个例子举的不太合适，只是为了说明泛型方法的特性。
                    T test = container.getKey();
                    return test;
                }
            
                //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic<Number>这个泛型类做形参而已。
                public void showKeyValue1(Generic<Number> obj){
                    Log.d("泛型测试","key value is " + obj.getKey());
                }
            
                //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?
                //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类
                public void showKeyValue2(Generic<?> obj){
                    Log.d("泛型测试","key value is " + obj.getKey());
                }
            
                 /**
                 * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' "
                 * 虽然我们声明了<T>,也表明了这是一个可以处理泛型的类型的泛型方法。
                 * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。
                public <T> T showKeyName(Generic<E> container){
                    ...
                }  
                */
            
                /**
                 * 这个方法也是有问题的，编译器会为我们提示错误信息："UnKnown class 'T' "
                 * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。
                 * 所以这也不是一个正确的泛型方法声明。
                public void showkey(T genericObj){
            
                }
                */
            
            ```
        + 泛型上下边界
            使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类
            ```
            //上边界，<? extends T> 即传入的类型实参必须是指定类型的子类型
            <? extends Number> obj)
            
            //下边界 ：<? super T>  
            <? super Number> obj)  
           ```
        + 符号
        
            E - Element (在集合中使用，因为集合中存放的是元素)  
            T - Type（Java 类）                    
            K - Key（键）                    
            V - Value（值）                    
            N - Number（数值类型）                 
            ？ -  表示不确定的java类型
            
        
        
     