---
layout:     post
title:      第二篇 Java集合、IO
subtitle:   知识积累
date:       2018-12-12
author:     guchaolong
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
       - Java
---
>集合 IO

1. ### 集合
    数组，但是初始化之后尺寸固定，只能通过索引取出，所以要用到集合，删除某个元素之后，需要移动
    后续元素
    
    + Collection 集合类的跟接口
        + List 有序可重复
        + Set 无序 不可重复
    + Map 键值对
    
    Java集合使用Iterator遍历元素
    
    （JDK遗留类 不应该再继续使用的有：HashTable Vector Stack）
    
2. ### List
    ArrayList是大小可变的，底层采用数组保存元素，添加元素的时候，如果数组已经满了，就创建一个更大的新数组
    并把旧数组中的元素复制到新数组中去，然后用新数组替换旧数组，就可以继续添加元素了  
    LinkedList底层是双向链表，每个元素都有一个指针指向下一个元素，添加元素时 不需要移动元素，只要把
    添加的元素指向下一个元素就行了
    区别：前者查询快，后者因为需要从头查找 慢；添加元素到末尾 两者都快；添加元素到指定位置，前者因为
    要移动元素 会慢 后者快；前者占用内存少 后者多 （优先考虑ArrayList）
    
    遍历List<E> :  
    + for循环
    + iterator
    + foreach (编译器底层会把foreach编程iterator的调用)
    
    list.contains(Object o) 方法，是根据equals方法判断的，而Object类的equals方法就是用的==
    也就是判断是否是同一个对象，所以通常要覆盖掉equals方法才能准确判断
    
3. ### Set
    不重复  
    放入Set的元素必须正确实现equals和hashCode
    可以利用Set去重
    
4. ### Map
    作为key的对象必须正确复写equals方法 如String Integer Long...
    遍历Key: keySet()可以的到key的集合，遍历key 然后get(key)  
    同时遍历Key和Value: entrySet() 可以得到key value的集合，entry.getKey() 、entry.getValue()  
    
    hashCode 、 equals
    两个对象相等 则hashCode必须相等  
    两个对象不相等 hashCode不需要相等
    
    一个对象覆写了equals方法，就必须覆写hashCode方法
    a.equals(b) == true  ---> a.hashCode() == b.hashCode(  
    a.equals(b) == false ---> a和b的hashCode尽量不要相等
    
    可以借助Objects.equals()方法覆写equals方法
    
    + HashMap  
       通过计算key的hashCode定位到 **key** 的存储位置，继而获得value
    + SortedMap : 遍历时以key的顺序排序（实现类是TreeMap）
    
    Map排序只能作用于key 和value没任何关系  
    
    Properties类用于读写配置文件xxx.properties  
    可以从classPath或文件系统读取  
    Properties底层是HashTable 也是键值对
    但是不要调用继承而来的get()/set()  而是使用setProperty()/getProperty
    
5. ### Queue
    Queue<E> 是一个先进先出的队列  
    跟排队一样，在队尾加入，队头处理完就移除  
    
    LinkedList<E> 实现了Queue<E>接口,所以可以直接把LinkedList作为Queue使用  
    方法： 
    + add     添加                     如果队列已满，则抛出一个IIIegaISlabEepeplian异常
    + offer   添加并返回true           如果队列已满，则返回false
    
    + remove  移除并返回头部的元素     如果队列为空，则抛出一个NoSuchElementException异常
    + poll    移除并返问队列头部的元素 如果队列为空，则返回null
    
    + element 返回队列头部的元素       如果队列为空，则抛出一个NoSuchElementException异常
    + peek    返回队列头部的元素       如果队列为空，则返回null
    
    + put     添加一个元素             如果队列满，则阻塞
    + take    移除并返回队列头部的元素 如果队列为空，则阻塞  
    
    PriorityQueue<E>的出队顺序于元素的优先级有关,相当于VIP客户   
     
    在获取队首元素时 总是获取优先级最高的元素(放入队列中的元素必须实现Comparable接口)
    或者new PriorityQueue<>(new Comparator<T>(...那么类就不用实现Comparable接口了  
    
    Deque<E> 双端队列（double ended queue)  
    添加 可以到队首 也可以到队尾
    删除 也是  
    使用Deque<E>时 总是调用xxxFirst()/xxxLast()以便和Queue方法区分开  
     
    实现类有ArrayDeque和LinkedList  
    
    Deque<String> obj = new LinkedList<>();  
    在使用时，总是用特定的接口引用它，这是为了使代码的抽象层次更高，接口本身定义的方法
    代表了特定的用途  
    如果是LinkedList<String> obj = new LinkedList<>();obj.offerLast();这就很难看出这里的对象用途
    是一个Deque,如果是把LinkedList作为List使用，就应该是List<String> list = new LinkedList<>()
    ,可见，面向对象编程它的一个原则就是尽量持有接口，而不是实现类  
    
6. Stack 栈
    是一种后进先出的数据结构  
    
    两个重要方法：  
    push() 把元素压栈  
    pop() 把栈顶元素弹出  
    
    用Deque可以实现栈的功能（避免使用Deque的其他方法）  
    push()---addFirst()  
    pop()----removeFirst()  
    peek()----peekFirst()  
    
    Stack的作用  
    + 方法 函数的嵌套调用 如main方法   
    + 嵌套调用过多会造成栈溢出StackOverFlowError  
    + 将整数转换为16进制的String  
    12500->Ox30d4  
    12500/16 = 781...4   把4压栈  
    781/16 = 48...d   把d压栈  
    48/16 = 3...0   把0压栈  
    3/16 = 0...3   把3压栈  
    把栈中元素顺序弹出 30d4
    + 将中缀表达式转换为后缀表达式
    中缀表达式 1 + 2 * (9 -5)  
    后缀表达式 1 2 9 5 - * +  
    1295依次入栈，遇到-时 弹出栈顶的两个元素5和9 计算9-5=4，把4压栈，遇到*时，弹出栈顶两个元素
    4和2，计算4/*2=8，压栈， 遇到+ 弹出栈顶两个元素，计算1+8=9 压栈，最后计算结束，弹出唯一一个元素9  
    
    不要使用遗留类Stack
    
# IO
    
输入（input）：把数据读到内存，如读硬盘上某个文件 从网络读取  
输出（output）：从内存输出到外部，如写到硬盘上的某个文件  
IO流：二进制数据最小以byte（字节流）为单位；字符流传输的最小数据单位时char,字符流输出的byte取决于编码方式  
同步IO:读写时等待数据返回 才能执行后续代码；编写简单 CPU效率低（JDK的java.io是同步IO）  
异步IO:读写IO发出请求，然后立刻执行后续代码；编写复杂 CPU执行效率高（JDK的java.nio是异步IO）  

FileInputStream  
    int read():读取下一个字节，并返回改字节对应的int值（0-255）,末尾-1
    int read(byte [] b):读取若干字节到数组b中，返回读取的字节数  
FileOutputStream  
    write(byte[] b):写入b中的所有字节  
    write(byte[] b,int off,int len):写入b指定范围的字节  
    void flush():将缓冲区的内容输出  
    
把项目依赖的资源放在classpath中可以避免文件路径的依赖（相对路径）  
Class对象的getResourceAsStream("")可以从classpath中读取资源（需要检查返回的stream是否为null）  

序列化  
把一个java对象变成二进制内容（byte[]），然后就可以把该数组保存在文件中 或在网络中传输
    

